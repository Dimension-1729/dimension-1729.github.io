---
title: tar
date: 2026-02-12 12:00:00 +0800
categories: linux
toc: true
media_subpath: /assets/media/
image: tar.png
tags: [linux, utilities, command, ]
pin: false
math: true
mermaid: true
comments: true
---


### Tar command with useful usage flags with their exlanation and use cases.

This guide will walk you through different options, flags and where you might need them in active engagement.

#### Basic Commands
1. **Creates a new archive**
   ```bash
   tar -cvf backup.tar /path/to/directory
   ``` 
    - c ‚Üí create
    - v ‚Üí verbose
    - f ‚Üí filename  

    **What it does?**  
    Recursively archives files/directories.  

    **Pentesting Use Cases:**  
    * Data exfiltration staging
    * Bundling loot
    * Archiving sensitive directories before transfer 

    üí° On compromised systems, tar is almost always installed ‚Äî reliable for staging data.  
***
2. **Extract an archive**
   ```bash
   tar -xvf backup.tar
   ``` 
    - x ‚Üí extract
    - v ‚Üí verbose
    - f ‚Üí filename  

    **What it does?**  
    Extract archive contents.  

    **Pentesting Use Cases:**  
    * Deploying uploaded tools  
    * Unpacking privesc scripts  
    * Extracting backups found on system
      
    üí° Extracting untrusted archives can be dangerous (path traversal risk).
***

3. **List Archive Content**
   ```bash
   tar -tvf backup.tar
   ``` 
    - t ‚Üí view
    - v ‚Üí verbose
    - f ‚Üí filename  

    **What it does?**  
    View archive contents without extracting.  

    **Pentesting Use Cases:**  
    * Before extracting unknown archive:

    ```bash
    tar -tf suspicious.tar
    ```    
    * Prevents accidental file overwrite  
    * Detects malicious archive entries like:

    ```bash
    ../../etc/passwd
    ```

***
4.  **--one-top-level**  
      ```bash
      tar -xvf archive.tar --one-top-level=name(optional)
      ```
      **What it does?**  
        Creates a new directory and extracts all files inside it. Prevents path traversal attacks.  

      **Pentesting Use Cases:**  
        * Safe handling of untrusted archives  
        * Secure DevOps extraction

***

5. **Append Files**
   ```bash
    tar -rf backup.tar newfile.txt
   ```
   **What it does?**  
    Add files to end of archive.  

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Add new loot incrementally without rebuilding archive.
***
6. **Update (Append only if newer)**
   ```bash
   tar -uvf backup.tar file.txt
   ```
    **What it does?**  
    Versioned archiving:
    Adds file only if newer than archived version.  
    It DOES NOT replace old copy ‚Äî it appends a new version.  
    Archive may contain multiple versions.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Incremental backups during long engagement  
    * Preserving timeline of file changes

7. **Compare Archive to Filesystem**
   ```bash
    tar -dvf archive.tar
   ```
   **What it does?**  
     * Compare archive with current filesystem.
     * Detect modified files.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Forensic analysis
    * Detect file tampering

    üí° Useful during post-exploitation cleanup.
***
8. **Delete From Archive**
   ```bash
    tar --delete -f archive.tar file.txt
   ```
   **What it does?**  
     * Remove file from archive.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

***
***  
###  Advanced Commands  
1. **Incremental Backup**
   ```bash
    tar -g snapshot.file -cvf backup.tar /home
   ```
   **What it does?**  
     * Tracks filesystem changes using snapshot file.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Stealth data exfiltration
    * Monitoring changed files  
    
    **Usage**  
    `snapshot.file` stores metadata about:

    * inode numbers

    * timestamps

    * device numbers

    * file state
    ```bash
    tar -g snapshot.file -cvf backup2.tar /home
    ```
    Now tar compares:

    * Current filesystem

    * Data inside snapshot.file

    And only archives:

    Modified files and Newly created files

    üî• This makes backup2.tar much smaller.  

    **Restore**  
    You must extract in order:
    ```bash
    mkdir restore
    cd restore

    tar -xvf backup.tar
    tar -xvf backup2.tar -g /dev/null
    ```


   #### Why /dev/null?

    During creation

    The snapshot file is actively used.

    During extraction

    The snapshot file is NOT used.

    But tar‚Äôs syntax requires that if archive was created with -g, you must also supply -g when extracting.

    It‚Äôs a syntactic requirement, not a functional one.

    üß© Why Tar Requires -g at Extraction

    GNU tar stores special incremental metadata inside the archive:

    Directory state

    Deletion records

    Dump level markers

    When extracting incremental archives, tar switches into incremental restore mode only if -g is specified.

    If you don't use -g, tar may:

    Ignore deletion markers

    Not properly restore directory metadata

    Behave differently with incremental archives

    So -g tells tar:

    ‚ÄúThis archive is incremental. Process it accordingly.‚Äù  
   #### üß† Why /dev/null Specifically?

    During extraction:

    Tar needs a filename after -g

    But it does NOT actually read the snapshot file

    It only checks that one is supplied

    So we give it:

    ```python
    /dev/null
    ```


    Because:

    It exists

    It‚Äôs harmless

    It contains nothing

    It discards any write attempts

#### Step 2: Create a System User for the Binary

1. **Create a system user with no login access:**
   ```bash
   sudo useradd -s /usr/sbin/nologin -r -M cloudflared
   ```
   - **What is a system user?**
     A system user is a user account created for running system processes or services, rather than for interactive login by human users.
   - **What is `nologin` access?**
     Using `nologin` for the shell means the user cannot log in interactively, which enhances security by preventing potential misuse of the account.
   - **Explanation of `-s`, `-r`, and `-M`:**
     - `-s /usr/sbin/nologin`: Sets the user's shell to `nologin`, preventing interactive logins.
     - `-r`: Creates a system account, typically with a UID lower than 1000.
     - `-M`: Prevents the creation of a home directory for the user.


#### Step 3: Configure the Binary

1. **Create and edit the configuration file:**
   ```bash
   sudo nano /etc/default/cloudflared
   ```

   **Example configuration:**
   ```ini
   # Commandline args for cloudflared, using Cloudflare DNS
   CLOUDFLARED_OPTS=--port 5053 --upstream https://1.1.1.1/dns-query --upstream https://1.0.0.1/dns-query
   ```
   
   - **What is `/etc/default` directory for?**
     The `/etc/default` directory is used to store configuration files for various system services. These files typically define environment variables and command-line options.



3. **Set the appropriate permissions for the configuration file and the binary:**
   ```bash
   sudo chown cloudflared:cloudflared /etc/default/cloudflared
   sudo chown cloudflared:cloudflared /usr/local/bin/cloudflared
   ```
   - **Why set owner and group to `cloudflared`?**
     Changing the ownership ensures that only the `cloudflared` user has the necessary permissions to read and execute the binary, enhancing security.



#### Step 4: Create a Systemd Service

1. **Create and edit the systemd service file:**
   - **What is `/etc/systemd/system/` directory for?**
     This directory is used to store service unit files that define systemd services. These files control how services are started, stopped, and managed on the system.

   ```bash
   sudo nano /etc/systemd/system/cloudflared.service
   ```

   **Service file configuration:**

   ```ini
   [Unit]
   Description=cloudflared DNS over HTTPS proxy
   After=syslog.target network-online.target

   [Service]
   Type=simple
   User=cloudflared
   EnvironmentFile=/etc/default/cloudflared
   ExecStart=/usr/local/bin/cloudflared proxy-dns $CLOUDFLARED_OPTS
   Restart=on-failure
   RestartSec=10
   KillMode=process

   [Install]
   WantedBy=multi-user.target
   ```

   **Explanation of the directives:**
   - **[Unit]**
     - **Description**: Describes the service.
     - **After**: Specifies the service dependencies. The service will start after the listed targets.
   - **[Service]**
     - **Type**: Defines the service type. `simple` means the service will be considered started right after the `ExecStart` command is executed.
     - **User**: The user under which the service will run.
     - **EnvironmentFile**: Specifies the file containing environment variables.
     - **ExecStart**: The command to start the service.
     - **Restart**: Defines the restart policy. `on-failure` restarts the service if it fails.
     - **RestartSec**: The time to wait before restarting the service.
     - **KillMode**: How the service's processes are killed.
   - **[Install]**
     - **WantedBy**: Specifies the target under which the service should be started. `multi-user.target` means the service will start in multi-user mode (default for most servers).

#### Step 5: Enable and Start the Service

1. **Enable the service to start on boot:**

   ```bash
   sudo systemctl enable cloudflared
   ```

2. **Start the service:**

   ```bash
   sudo systemctl start cloudflared
   ```

3. **Check the status of the service:**

   ```bash
   sudo systemctl status cloudflared
   ```

#### Additional Information

- **What is `multi-user.target`?**
  `multi-user.target` is a systemd target that signifies the system is in multi-user mode. It's similar to the traditional runlevel 3, where multiple users can log in.


This guide provides a comprehensive example of how to install a binary, create a system user, configure the binary, and set up a systemd service to manage the binary. Adjust the specific paths, user names, and configuration options as needed for your particular use case.
