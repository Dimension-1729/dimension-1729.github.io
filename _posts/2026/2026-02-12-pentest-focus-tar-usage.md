---
title: tar
date: 2026-02-12 12:00:00 +0800
categories: linux
toc: true
media_subpath: /assets/media/
image: tar-1.png
tags: [linux, utilities, command, ]
pin: false
math: true
mermaid: true
comments: true
---


### Tar command: Useful usage flags with their exlanation and use cases.

This guide will walk you through different options, flags and where you might need them in active engagement.

### **Basic Commands**
1. ####  **Creates a new archive**
   ```bash
   tar -cvf backup.tar /path/to/directory
   ``` 
    - c ‚Üí create
    - v ‚Üí verbose
    - f ‚Üí filename  

    **What it does?**  
    Recursively archives files/directories.  

    ##### **Handling Corrupt Files**
    ```bash
    tar -cvf backup.tar /root --ignore-failed-read
    ```

    ##### **Verify Archive Integrity**
    ```bash
    tar -cvf backup.tar /etc -W
    ```
    - Exfiltrating large datasets

    - Ensuring archive not corrupted

    ##### **Deleting Original Files After Archiving**
    ```bash
    tar -cvf loot.tar /tmp/loot --remove-files
    ```
    - Clean artifacts after staging
    - Remove sensitive traces

    ##### **Preserves Absolute Path**
    ```bash
    tar -P -cf archive.tar /etc/passwd
    ```
    - Tar removes leading / by default as it;
      - Prevent overwriting arbitrary system files on extraction  
      - Avoid archive extraction attacks
      - Safer default behavior

    **Pentesting Use Cases:**  
    * Data exfiltration staging
    * Bundling loot
    * Archiving sensitive directories before transfer 

    üí° On compromised systems, tar is almost always installed ‚Äî reliable for staging data.  
  ***
2. #### **Extract an archive**
   ```bash
   tar -xvf backup.tar
   ``` 
    - x ‚Üí extract
    - v ‚Üí verbose
    - f ‚Üí filename  

    **What it does?**  
    Extract archive contents. 

    ##### **Keep old files**
    ```bash
    tar -xvf archive.tar -k
    ```
    - Avoid damaging system

    ##### **Do not overwrite if target is newer**
    ```bash
    tar -xvf archive.tar --keep-newer-files
    ```

    ##### **Change Extraction Path**
    ```bash
    tar -xvf archive.tar -C /tmp
    ```

    ##### **Unlink(Delete) befor extraction**
    ```bash
    tar -xUf archive.tar
    ```
    - Deletes (unlinks) the existing file first.
    - For each file:
      - If file exists ‚Üí remove it completely
      - Then create fresh file
    - Normal Tar behavior:
      - Tar opens it
      - Overwrites contents
      - But file metadata may remain

    **Pentesting Use Cases:**  
    * Deploying uploaded tools  
    * Unpacking privesc scripts  
    * Extracting backups found on system
      
    üí° Extracting untrusted archives can be dangerous (path traversal risk).
  ***
3. #### **List Archive Content**
   ```bash
   tar -tvf backup.tar
   ``` 
    - t ‚Üí view
    - v ‚Üí verbose
    - f ‚Üí filename  

    **What it does?**  
    View archive contents without extracting.  

    **Pentesting Use Cases:**  
    * Before extracting unknown archive:

    ```bash
    tar -tf suspicious.tar
    ```    
    * Prevents accidental file overwrite  
    * Detects malicious archive entries like:

    ```bash
    ../../etc/passwd
    ```
  ***
4.  #### **--one-top-level**  
      ```bash
      tar -xvf archive.tar --one-top-level=name(optional)
      ```
      **What it does?**  
        Creates a new directory and extracts all files inside it. Prevents path traversal attacks.  

      **Pentesting Use Cases:**  
        * Safe handling of untrusted archives  
        * Secure DevOps extraction

  ***
5. #### **Append Files**
   ```bash
    tar -rf backup.tar newfile.txt
   ```
   **What it does?**  
    Add files to end of archive.  

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Add new loot incrementally without rebuilding archive.
  ***
6. #### **Update (Append only if newer)**
   ```bash
   tar -uvf backup.tar file.txt
   ```
    **What it does?**  
    Versioned archiving:
    Adds file only if newer than archived version.  
    It DOES NOT replace old copy ‚Äî it appends a new version.  
    Archive may contain multiple versions.

    ‚ö†Ô∏è Cannot be used on compressed archives.

    **To extract a specific version file from archive**  
    ```ini
    tar -xvf backup.tar --occurrence=2 file.txt
    ```
    **Pentesting Use Cases:**  
    * Incremental backups during long engagement  
    * Preserving timeline of file changes
  ***
7. #### **Compare Archive to Filesystem**
   ```bash
    tar -dvf archive.tar
   ```
   **What it does?**  
     * Compare archive with current filesystem.
     * Detect modified files.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Forensic analysis
    * Detect file tampering

    üí° Useful during post-exploitation cleanup.
  ***
8. #### **Delete From Archive**
   ```bash
    tar --delete -f archive.tar file.txt
   ```
   **What it does?**  
     * Remove file from archive.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

====================================================================
###  ***Advanced Commands***
1. #### **Incremental Backup**
   ```bash
    tar -g snapshot.file -cvf backup.tar /home
   ```
   **What it does?**  
     * Tracks filesystem changes using snapshot file.

    ‚ö†Ô∏è Cannot be used on compressed archives.   

    **Pentesting Use Cases:**  
    * Stealth data exfiltration
    * Monitoring changed files  
    
    **Usage**  
    `snapshot.file` stores metadata about:

    * inode numbers

    * timestamps

    * device numbers

    * file state
    ```bash
    tar -g snapshot.file -cvf backup2.tar /home
    ```
    Now tar compares:

    * Current filesystem

    * Data inside snapshot.file

    And only archives:

    Modified files and Newly created files

    üî• This makes backup2.tar much smaller.  

    **Restore**  
    You must extract in order:
    ```bash
    mkdir restore
    cd restore

    tar -xvf backup.tar
    tar -xvf backup2.tar -g /dev/null
    ```


   ##### **Why /dev/null?**

    `During creation`

    The snapshot file is actively used.

    `During extraction`

    The snapshot file is NOT used.

    But tar‚Äôs syntax requires that if archive was created with -g, you must also supply -g when extracting.

    It‚Äôs a syntactic requirement, not a functional one.

    ##### üß© **Why Tar Requires -g at Extraction**

    GNU tar stores special incremental metadata inside the archive:

    - Directory state

    - Deletion records

    - Dump level markers

    When extracting incremental archives, tar switches into incremental restore mode only if -g is specified.

    If you don't use -g, tar may:

    - Ignore deletion markers

    - Not properly restore directory metadata

    - Behave differently with incremental archives

    So -g tells tar:

    ‚ÄúThis archive is incremental. Process it accordingly.‚Äù  
   ##### üß† **Why /dev/null Specifically?**

    During extraction:

    Tar needs a filename after -g

    But it does NOT actually read the snapshot file

    It only checks that one is supplied

    So we give it:

    ```python
    /dev/null
    ```


    Because:

    It exists

    It‚Äôs harmless

    It contains nothing

    It discards any write attempts

    ##### **Want to force a new full backup**
    ```bash
    tar -g snapshot.file --level=0 -cvf full.tar /home
    ```
    - this truncates snapshot file

  ***
2.  #### **Sparse Files**
   ```bash
    tar -S -cvf db.tar database.img
   ```
   **What it does?**  
  * Efficiently archives sparse files.  
  * Huge files with empty blocks.  
  -  Example:  
    - VM disk images  
    - Database files 

  **Pentesting Use Cases:**  
  * Archiving VM images found on system
  * Dumping database files efficiently
  ***
3.  #### **Sparse Files**
   ```bash
    tar -S -cvf db.tar database.img
   ```
   **What it does?**  
  * Efficiently archives sparse files.  
  * Huge files with empty blocks.  
  -  Example:  
    - VM disk images  
    - Database files 

  **Pentesting Use Cases:**  
  * Archiving VM images found on system
  * Dumping database files efficiently
***







